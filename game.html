<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ケバブケースゲーム</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'メイリオ', 'Meiryo', 'Hiragino Kaku Gothic ProN', sans-serif;
      overflow: hidden;
    }
    .word {
      position: absolute;
      font-size: 2.5rem;
      font-weight: bold;
    }
    #skewer {
      position: absolute;
      right: 50px;
      top: 50%;
      transform: translateY(-50%);
      transition: left 0.2s;
    }
  </style>
</head>
<body class="relative h-screen bg-gray-100 bg-[url('image/target_cut.png')] bg-no-repeat bg-center bg-fixed min-h-screen">

  <!-- ヘッダー -->
  <header class="bg-amber-300/80 w-full shadow-md p-1 sticky top-0">
    <h1 class="text-center text-lg m-2">
      ゲーム画面：落ちてくる言葉に串をさしてケバブケース作れ！
    </h1>
  </header>

  <!-- メインコンテンツ -->
  <main id="gameArea" class="relative w-full" style="height: calc(100vh - 60px - 60px);">
    <!-- 串 -->
    <img id="skewer" src="image/skewer.png" alt="skewer"
         class="w-auto h-auto max-w-[150px] max-h-[150px] object-contain">
    <!-- ボタン -->
    <button id="moveButton" class="fixed bottom-[70px] right-5 px-4 py-2 bg-blue-500 text-white rounded">
      串を刺す
    </button>
    <button id="backButton" class="fixed bottom-[70px] left-5 px-4 py-2 bg-blue-500 text-white rounded"
            onclick="location.href='index.html'">戻る</button>
  </main>

  <!-- フッター -->
  <footer class="bg-amber-300/80 w-full shadow-inner p-1 fixed bottom-0">
    <p class="text-center m-2">@NOA</p>
  </footer>

  <script>
    const words = ["apple ringo", "banana.test", "sakuraCherry", "date", "fig", "grape"];
    const wordElements = [];
    const results = [];

    const gameArea = document.getElementById("gameArea");
    const skewer = document.getElementById("skewer");
    let skewerLeft = gameArea.clientWidth - 100; // 初期位置
    let flying = false; // 串飛行中フラグ

    // 単語生成
    function createWord() {
      const word = document.createElement("div");
      word.classList.add("word");
      word.textContent = words[Math.floor(Math.random() * words.length)];

      const leftMargin = 50;
      const rightMargin = 220;
      const maxLeft = gameArea.clientWidth - leftMargin - rightMargin - 50;
      word.style.left = leftMargin + Math.random() * maxLeft + "px";

      word.style.top = "0px";
      word.dataset.speed = 0.5 + Math.random() * 1.5; // 落下速度
      gameArea.appendChild(word);
      wordElements.push(word);
    }

    //-----------------------------------------------------------
    // 串と文字の衝突判定（安定版）
    //-----------------------------------------------------------
    function hitCheckSkewer(skewerRect, wordRect) {
      const tolerance = 5; // px
      const skewerLeftX = skewerRect.left;
      const skewerRightX = skewerRect.right;
      const skewerCenterY = skewerRect.top + skewerRect.height / 2;

      const horizontalHit = (skewerLeftX <= wordRect.right + tolerance) &&
                            (skewerRightX >= wordRect.right - tolerance);
      const verticalHit = (skewerCenterY >= wordRect.top) &&
                          (skewerCenterY <= wordRect.bottom);
      return horizontalHit && verticalHit;
    }

    // 単語落下＆衝突判定
    function updateWords() {
      wordElements.forEach((word, index) => {
        const speed = parseFloat(word.dataset.speed);
        word.style.top = parseFloat(word.style.top) + speed + "px";

        const wordRect = word.getBoundingClientRect();
        const skewerRect = skewer.getBoundingClientRect();

        if (hitCheckSkewer(skewerRect, wordRect)) {
          const wordText = word.textContent || "";
          const skewerCenterY = skewerRect.top + skewerRect.height / 2;
          const hitPercent = ((skewerCenterY - wordRect.top) / wordRect.height) * 100;
          const clampedHitPercent = Math.min(Math.max(hitPercent, 0), 100).toFixed(1);

          results.push({ word: wordText, hitPercent: clampedHitPercent });
          console.log("衝突しました:", wordText, clampedHitPercent);

          word.remove();
          wordElements.splice(index, 1);

          setTimeout(() => {
            window.location.href = `result.html?word=${encodeURIComponent(wordText)}&hitPercent=${clampedHitPercent}`;
          }, 100);
        }

        // 画面下に到達したら削除
        if (parseFloat(word.style.top) > window.innerHeight) {
          word.remove();
          wordElements.splice(index, 1);
        }
      });
    }

    // 串移動
    skewer.style.left = skewerLeft + "px";
    document.getElementById("moveButton").addEventListener("click", () => {
      if (flying) return;
      flying = true;
      const speed = 40; // px/frame

      function fly() {
        skewerLeft -= speed;
        skewer.style.left = skewerLeft + "px";

        if (skewerLeft + skewer.offsetWidth > 0) {
          requestAnimationFrame(fly);
        } else {
          skewerLeft = gameArea.clientWidth - skewer.offsetWidth;
          skewer.style.left = skewerLeft + "px";
          flying = false;
        }
      }

      requestAnimationFrame(fly);
    });

    // ウィンドウリサイズ時
    window.addEventListener('resize', () => {
      if (!flying) {
        skewerLeft = gameArea.clientWidth - 100;
        skewer.style.left = skewerLeft + "px";
      }
    });

    // ゲームループ
    setInterval(() => {
      if (Math.random() < 0.03) createWord();
      updateWords();
    }, 16); // 約60fps
  </script>

</body>
</html>